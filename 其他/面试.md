- 消息中间件的:
  -  要你设计一个消息中间件你会怎么设计?
     - 这个问题就参照Kafka的设计进行说明，包括有
       - Product:数据压缩，批量发送，可恢复性错误自动重试，幂等性
       - Consumer:推拉模式，推就是实时性比较好，但是客户端的消费能力跟不上，拉就是正好相反
       - Topic:作为数据的分类
       - Partition:作为分类的分区，用来提供给Consumer的并发消费，并且每个Partition是基于磁盘的顺序追加(其实是先写到了操作系统的页缓存)，就可以做到速度匹配内存的随机读写。
       - replication:用来做软件层面的高可用架构
       - ack:可以用来保证消息的不丢失

- 架构设计:
  - 原来的项目一天的数据量差不多是二十万左右,如果你项目的数据量扩大十倍你改如何设计项目的架构?
    - Mysql已经扛不住了，如果你的系统已经成型了，不准备重构，我们可以根据业务分析，把最重的那一块也就是数据量相对比较大的给拆分出来，这做成一个单独的服务，可以把数据库独立出来，并且原来的架构中再能加缓存的地方加入缓存,数据量特别大的表需要做分库分表。
    - 如果整体重构可以直接上微服务，把服务按照业务模块进行划分，数据库资源独立，前期数据库设计方面，通过前面老系统的积累，做出适当的冗余设计，去掉当初不合理的设计字段，以及字段的数据结构类型等，并且为分库分表做出提前设计，在业务开发中避免使用join这种，整体可以用到大量的缓存设计提供整体性能，利用MQ做到复杂业务的异步处理，以及在帮助某些业务进行削峰处理，如果这种情况一些很复杂的查询还是不理想，就需要引入搜索引擎。


- 缓存:
  - 缓存穿透?
    - 说明:也就是大量的在数据量中不存在缓存中的Key进行访问，导致全部请求走到数据库导致数据库被打死。
    - 方案:
      1. 对于这些key缓存一个null，设置比较短的过期时间
      2. 加一层布隆过滤器，先判断一下这个key是否存在，存在再走缓存，不存在就直接返回了
  - 缓存击穿?
    - 说明:就是一个热点key失效了，大量的请求过来访问导致请求全都打到数据库了
    - 方案：就是在请求这个key的入口加锁，只有一个请求是走数据库，拿到数据后丢到缓存中，其他的请求会走缓存，参考SpringCache
  - 缓存雪崩？
    - 说明：缓存挂掉了
    - 方案：
      1. 事前:做高可用
      2. 事中:对数据库加一层熔断降级保护
      3. 事后:持久化的redis快速恢复
  - 热点同时Key失效?
    1. 给Key加的缓存时间在固定时间的同时添加一个随机时间
    2. 缓存击穿一样的加锁
- redis:
  -  redis主从的异步复制，脑裂
     -  解决异步复制导致的数据丢失:
        -  通过配置min-slaves-max-lag这个配置，就代表如果slave复制数据与ack的延迟时间太长，就认为如果master宕机会丢失很多的数据
        -  通过配置min-slaves-to-write=1配置至少一个从服务跟我之间延迟时间小于上面的配置时间，否则master就会拒绝写请求


