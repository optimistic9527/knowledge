### Linked List
 * 链表即是由节点（Node）组成的线性集合，每个节点可以利用指针指向其他节点。它是一种包含了多个节点的、能够用于表示序列的数据结构。
 * **单向链表**: 链表中的节点仅指向下一个节点，并且最后一个节点指向空。
 * **双向链表**: 其中每个节点具有两个指针 p、n，使得 p 指向先前节点并且 n 指向下一个节点；最后一个节点的 n 指针指向 null。
 * **循环链表**：每个节点指向下一个节点并且最后一个节点指向第一个节点的链表。
 * 时间复杂度:
   * 索引: `O(n)`
   * 搜索: `O(n)`
   * 插入: `O(1)`
   * 移除: `O(1)`

### Stack
 * 栈是元素的集合，其包含了两个基本操作：push 操作可以用于将元素压入栈，pop 操作可以将栈顶元素移除。
 * 遵循后入先出（LIFO）原则。
 * 时间复杂度:
  * 索引: `O(n)`
  * 搜索: `O(n)`
  * 插入: `O(1)`
  * 移除: `O(1)`

### Queue
 * 队列是元素的集合，其包含了两个基本操作：enqueue 操作可以用于将元素插入到队列中，而 dequeue 操作则是将元素从队列中移除。
 * 遵循先入先出原则 (FIFO)。
 * 时间复杂度:
  * 索引: `O(n)`
  * 搜索: `O(n)`
  * 插入: `O(1)`
  * 移除: `O(1)`

### Tree
* 树是无向、连通的无环图。
![](../image/树.jpg)

1. **父节点**: 图中A节点就是B节点的父节点

2. **子节点**：图中B节点就是A节点的子节点

3. **兄弟节点**：图中B,C,D节点就是兄弟节点

4. **根节点**：没有父节点的节点就是根节点，图中E节点就是根节点

5. **叶子节点**：没有子节点的节点就是叶子节点，也就是图中的，G,H,I.J,K,L
6. **节点的高度**：节点到叶子节点的**最长路径**（边数）
7. **节点的深度**：根节点到这个节点所经历的**边的个数**
8. **节点的层数**：节点的深度+1
9. **树的高度**：根节点的高度
   ![](../image/树-高度-深度-层.jpg)

协助记忆容易混淆的三个概念：**高度** ，**深度**，**层**

```chinese
高度：其实就是从下往上度量，比如我们要度量第 10层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是0
```

```chinese
深度:在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0.
```

```chinese
层数：跟深度的计算类似，不过，计数起点是 1，也就是说根节位于第一层
```

### Binary Tree
 * **二叉树**:顾名思义,每个节点最多有两个”叉“，也就是两个子节点，分别是**左子节点**和**右子节点**。不过二叉树并不是要求每个节点都有两个字节点，有的节点只有左子节点，有的只有右子节点。
 * **满二叉树**: 图二中叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树（节点个数为2^n-1，n为层数）
 * **完美二叉树（Perfect Binary Tree）**: 二叉树中的每个叶节点都拥有两个子节点，并且具有相同的高度。
 * **完全二叉树**: 图三中叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树
 

![](../image/二叉树.jpg)

二叉树的存储方式：

- **基于指针或者引用的二叉链式存储法**

  ![](../image/二叉树链式存储.jpg)

- **基于数组的顺序存储方式**

  ![](../image/二叉树数组存储.jpg)

### Binary Search Tree

* 二叉搜索树（BST）是一种特殊的二叉树，其任何节点中的值都会大于或者等于其左子树中存储的值并且小于或者等于其右子树中存储的值。
* 时间复杂度:
  * 索引: `O(log(n))`
  * 搜索: `O(log(n))`
  * 插入: `O(log(n))`
  * 删除: `O(log(n))`

### Trie
* 字典树，又称基数树或者前缀树，能够用于存储键为字符串的动态集合或者关联数组的搜索树。树中的节点并没有直接存储关联键值，而是该节点在树中的挂载位置决定了其关联键值。某个节点的所有子节点都拥有相同的前缀，整棵树的根节点则是空字符串。


### Fenwick Tree
* 树状数组又称 Binary Indexed Tree，其表现形式为树，不过本质上是以数组实现。数组中的下标代表着树中的顶点，每个顶点的父节点或者子节点的下标能够通过位运算获得。数组中的每个元素包含了预计算的区间值之和，在整棵树更新的过程中同样会更新这些预计算的值。
* 时间复杂度:
  * 区间求值: `O(log(n))`
  * 更新: `O(log(n))`


### Segment Tree
* 线段树是用于存放间隔或者线段的树形数据结构，它允许快速的查找某一个节点在若干条线段中出现的次数.
* 时间复杂度:
  * 区间查询: `O(log(n))`
  * 更新: `O(log(n))`


### Heap
* 堆是一种特殊的基于树的满足某些特性的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。
* 时间复杂度:
  * 访问最大值 / 最小值: `O(1)`
  * 插入: `O(log(n))`
  * 移除最大值 / 最小值: `O(log(n))`


### Hashing
* 哈希能够将任意长度的数据映射到固定长度的数据。哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，即将这种现象称为碰撞。
* **Hash Map**: Hash Map 是一种能够建立起键与值之间关系的数据结构，Hash Map 能够使用哈希函数将键转化为桶或者槽中的下标，从而优化对于目标值的搜索速度。
* 碰撞解决
  * **链地址法（Separate Chaining）**: 链地址法中，每个桶是相互独立的，包含了一系列索引的列表。搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。
  * **开地址法（Open Addressing）**: 在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址法也是指某个元素的位置并不永远由其哈希值决定。
  
参考:  
[interviews](https://github.com/kdn251/interviews/blob/master/README-zh-cn.md#linked-list)